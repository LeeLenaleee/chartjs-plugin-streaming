/*!
 * chartjs-plugin-streaming v2.0.0-beta.1
 * https://nagix.github.io/chartjs-plugin-streaming
 * (c) 2021 Akihiko Kusanagi
 * Released under the MIT license
 */
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t(require("chart.js"),require("chart.js/helpers")):"function"==typeof define&&define.amd?define(["chart.js","chart.js/helpers"],t):(e="undefined"!=typeof globalThis?globalThis:e||self).ChartStreaming=t(e.Chart,e.Chart.helpers)}(this,(function(e,t){"use strict";function o(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}var a=o(e);function n(e,t,o){return Math.min(Math.max(e,t),o)}function r(e,o){const a=e.options.realtime,n=e.chart.options.plugins.streaming;return t.valueOrDefault(a[o],n[o])}const i="undefined"==typeof window?t.noop:window.cancelAnimationFrame;function s(e,o){if(!e.frameRequestID){const a=function(){o(),e.frameRequestID=t.requestAnimFrame.call(window,a)};e.frameRequestID=t.requestAnimFrame.call(window,a)}}function l(e){const t=e.frameRequestID;t&&(i.call(window,t),delete e.frameRequestID)}var c=Object.freeze({__proto__:null,clamp:n,resolveOption:r,cancelAnimFrame:i,startFrameRefreshTimer:s,stopFrameRefreshTimer:l});const d=new WeakMap;function u(e){const{originalScaleLimits:o}=function(e){let t=d.get(e);return t||(t={originalScaleLimits:{}},d.set(e,t)),t}(e),a=e.scales;return t.each(a,(e=>{const t=e.id;o[t]||(o[t]={duration:r(e,"duration"),delay:r(e,"delay")})})),t.each(o,((e,t)=>{a[t]||delete o[t]})),o}function m(e,t,o,a){const{chart:i,axis:s}=e,{minDuration:l=0,maxDuration:c=1/0,minDelay:d=-1/0,maxDelay:m=1/0}=a&&a[s]||{},f=e.options.realtime,p=r(e,"duration"),h=r(e,"delay"),g=n(p*(2-t),l,c);let y,b;return u(i),y=e.isHorizontal()?(e.right-o.x)/(e.right-e.left):(e.bottom-o.y)/(e.bottom-e.top),b=h+y*(p-g),f.duration=g,f.delay=n(b,d,m),g!==e.max-e.min}function f(e,t,o){const{chart:a,axis:i}=e,{minDelay:s=-1/0,maxDelay:l=1/0}=o&&o[i]||{},c=r(e,"delay")+(e.getValueForPixel(t)-e.getValueForPixel(0));return u(a),e.options.realtime.delay=n(c,s,l),!0}const p=a.default.registry.getScale("time"),h={millisecond:{common:!0,size:1,steps:[1,2,5,10,20,50,100,250,500]},second:{common:!0,size:1e3,steps:[1,2,5,10,15,30]},minute:{common:!0,size:6e4,steps:[1,2,5,10,15,30]},hour:{common:!0,size:36e5,steps:[1,2,3,6,12]},day:{common:!0,size:864e5,steps:[1,2,5]},week:{common:!1,size:6048e5,steps:[1,2,3,4]},month:{common:!0,size:2628e6,steps:[1,2,3]},quarter:{common:!1,size:7884e6,steps:[1,2,3,4]},year:{common:!0,size:3154e7}},g=Object.keys(h);function y(e,o,a){if(a){if(a.length){const{lo:n,hi:r}=t._lookup(a,o);e[a[n]>=o?a[n]:a[r]]=!0}}else e[o]=!0}function b(e,t){return t===e.xAxisID?"x":t===e.yAxisID&&"y"}const v=["pointBackgroundColor","pointBorderColor","pointBorderWidth","pointRadius","pointRotation","pointStyle","pointHitRadius","pointHoverBackgroundColor","pointHoverBorderColor","pointHoverBorderWidth","pointHoverRadius","backgroundColor","borderColor","borderSkipped","borderWidth","hoverBackgroundColor","hoverBorderColor","hoverBorderWidth","hoverRadius","hitRadius","radius","rotation"];function x(e){const t=e.realtime,o=t.refreshTimerID;o&&(clearInterval(o),delete t.refreshTimerID,delete t.refreshInterval)}function D(e){const o=e.realtime,a=r(e,"refresh");o.refreshTimerID||(o.refreshTimerID=setInterval((()=>{const a=r(e,"refresh");!function(e){const{chart:o,id:a,max:n}=e,i=r(e,"duration"),s=r(e,"delay"),l=r(e,"ttl"),c=r(e,"pause"),d=r(e,"onRefresh"),u=Date.now()-(isNaN(l)?i+s:l);let m,f,p,h;t.callback(d,[o]),o.data.datasets.forEach(((e,r)=>{const i=o.getDatasetMeta(r),s=b(i,a);if(s){const o=i.controller,a=e.data,r=a.length;if(c){for(m=0;m<r&&o.getParsed(m)[s]<n;++m);f=m+2}else f=0;for(m=f;m<r&&o.getParsed(m)[s]<=u;++m);p=m-f,isNaN(l)&&(p=Math.max(p-2,0)),a.splice(f,p),v.forEach((o=>{e.hasOwnProperty(o)&&t.isArray(e[o])&&e[o].splice(f,p)})),t.each(e.datalabels,(e=>{t.isArray(e)&&e.splice(f,p)})),"object"!=typeof a[0]&&(h={start:f,count:p})}})),h&&o.data.labels.splice(h.start,h.count),o.update("quiet")}(e),o.refreshInterval===a||isNaN(a)||(x(e),D(e))}),a),o.refreshInterval=a)}const w={data:["x","controlPointPreviousX","controlPointNextX"],dataset:["x"],tooltip:["x","caretX"]},R={data:["y","controlPointPreviousY","controlPointNextY"],dataset:["y"],tooltip:["y","caretY"]};function k(e,t,o){const a=e.$animations;for(let a=0,n=t.length;a<n;++a){const n=t[a];isNaN(e[n])||(e[n]-=o)}if(a)for(let e=0,n=t.length;e<n;++e){const n=a[t[e]];n&&(n._from-=o,n._to-=o)}}class I extends p{constructor(e){super(e),this.realtime=this.realtime||{}}init(e,t){super.init(e,t),D(this)}update(e,o,a){const n=this,{realtime:i,options:c}=n,{bounds:d,offset:u,ticks:m}=c,{autoSkip:f,source:p,major:h}=m,g=h.enabled;r(n,"pause")?l(i):(s(i,(()=>{!function(e){const{chart:o,id:a,realtime:n}=e,i=r(e,"duration"),s=r(e,"delay"),l=e.isHorizontal(),c=o.tooltip,d=c._active,u=Date.now();let m,f,p;l?(m=e.width,f=w):(m=e.height,f=R),p=m*(u-n.head)/i,!!l==!!e.options.reverse&&(p=-p),t.each(o.data.datasets,((e,t)=>{const n=o.getDatasetMeta(t);if(b(n,a)){const{data:e,dataset:t}=n,o=e||[];for(let e=0,t=o.length;e<t;++e)k(o[e],f.data,p);t&&k(t,f.dataset,p)}})),d&&d[0]&&b(o.getDatasetMeta(d[0].datasetIndex),a)&&k(c,f.tooltip,p);e.max=u-s,e.min=e.max-i,n.head=u}(n)})),i.head=Date.now()),c.bounds=void 0,c.offset=!1,m.autoSkip=!1,m.source="auto"===p?"":p,h.enabled=!0,super.update(e,o,a),c.bounds=d,c.offset=u,m.autoSkip=f,m.source=p,h.enabled=g}buildTicks(){const e=this,o=r(e,"duration"),a=r(e,"delay"),n=e.realtime.head-a,i=n-o,s=[1e15,n],l=[-1e15,i];Object.defineProperty(e,"min",{get:()=>l.shift(),set:t.noop}),Object.defineProperty(e,"max",{get:()=>s.shift(),set:t.noop});const c=super.buildTicks();return delete e.min,delete e.max,e.min=i,e.max=n,c}calculateLabelRotation(){const e=this.options.ticks,t=e.maxRotation;e.maxRotation=e.minRotation||0,super.calculateLabelRotation(),e.maxRotation=t}fit(){const e=this,t=e.options;super.fit(),t.ticks.display&&t.display&&e.isHorizontal()&&(e.paddingLeft=3,e.paddingRight=3,e._handleMargins())}draw(e){const o=this,{chart:a,ctx:n}=o,r=o.isHorizontal()?{left:e.left,top:0,right:e.right,bottom:a.height}:{left:0,top:e.top,right:a.width,bottom:e.bottom};o._gridLineItems=null,o._labelItems=null,t.clipArea(n,r),super.draw(e),t.unclipArea(n)}destroy(){l(this.realtime),x(this)}_generate(){const e=this,o=e._adapter,a=r(e,"duration"),n=r(e,"delay"),i=r(e,"refresh"),s=e.realtime.head-n,l=s-a,c=e._getLabelCapacity(l),{time:d,ticks:u}=e.options,m=d.unit||function(e,t,o,a){const n=o-t,r=g.length;for(let t=g.indexOf(e);t<r-1;++t){const{common:e,size:o,steps:r}=h[g[t]],i=r?r[r.length-1]:Number.MAX_SAFE_INTEGER;if(e&&Math.ceil(n/(i*o))<=a)return g[t]}return g[r-1]}(d.minUnit,l,s,c),f=function(e){for(let t=g.indexOf(e)+1,o=g.length;t<o;++t)if(h[g[t]].common)return g[t]}(m),p=d.stepSize||function(e,t,o,a){const n=t-e,{size:r,steps:i}=h[o];let s;if(!i)return Math.ceil(n/(a*r));for(let e=0,t=i.length;e<t&&(s=i[e],!(Math.ceil(n/(r*s))<=a));++e);return s}(l,s,m,c),b="week"===m&&d.isoWeekday,v=u.major.enabled,x=t.isNumber(b)||!0===b,D=h[m],w={};let R,k,I=l;if(x&&(I=+o.startOf(I,"isoWeek",b)),I=+o.startOf(I,x?"day":m),o.diff(s,l,m)>1e5*p)throw new Error(l+" and "+s+" are too far apart with stepSize of "+p+" "+m);R=I,v&&f&&!x&&!d.round&&(R=+o.startOf(R,f),R=+o.add(R,~~((I-R)/(D.size*p))*p,m));const z="data"===u.source&&e.getDataTimestamps();for(k=0;R<s+i;R=+o.add(R,p,m),k++)y(w,R,z);return R!==s+i&&1!==k||y(w,R,z),Object.keys(w).sort(((e,t)=>e-t)).map((e=>+e))}}I.id="realtime",I.defaults={bounds:"data",adapters:{},time:{parser:!1,unit:!1,round:!1,isoWeekday:!1,minUnit:"millisecond",displayFormats:{}},realtime:{},ticks:{autoSkip:!1,source:"auto",major:{enabled:!0}}},a.default.defaults.describe("scale.realtime",{_scriptable:e=>"onRefresh"!==e});var z={id:"streaming",beforeInit(e){const o=e.streaming=e.streaming||{},a=o.canvas=e.canvas,n=o.mouseEventListener=a=>{const n=t.getRelativePosition(a,e);o.lastMouseEvent={type:"mousemove",chart:e,native:a,x:n.x,y:n.y}};a.addEventListener("mousedown",n),a.addEventListener("mouseup",n),e.options.transitions.quiet={animation:{duration:0}}},afterInit(e){const{update:o,render:n,resetZoom:r}=e;if(e.update=a=>{"quiet"===a?(e.render=t.noop,o.call(e,a),e.render=n):o.call(e,a)},r){const o=a.default.registry.getPlugin("zoom");o.zoomFunctions.realtime=m,o.panFunctions.realtime=f,e.resetZoom=o=>{!function(e){const o=u(e);t.each(e.scales,(e=>{const t=e.options.realtime;if(t){const a=o[e.id];a?(t.duration=a.duration,t.delay=a.delay):(delete t.duration,delete t.delay)}}))}(e),r(o)}}},beforeUpdate(e){const t=e.options,o=t.scales;return o&&Object.keys(o).forEach((e=>{"realtime"===o[e].type&&(t.elements.line.capBezierPoints=!1)})),!0},afterUpdate(e){const{scales:o,streaming:a}=e;let n=!0;t.each(o,(e=>{e instanceof I&&(n&=r(e,"pause"))})),n?l(a):s(a,(()=>{!function(e){const t=e.streaming,o=e.options.plugins.streaming.frameRate,a=1e3/(Math.max(o,0)||30),n=t.lastDrawn+a||0,r=Date.now();n<=r&&(e.render(),t.lastMouseEvent&&setTimeout((()=>{const o=t.lastMouseEvent;o&&e._eventHandler(o)}),0),t.lastDrawn=n+a>r?n:r)}(e)}))},beforeDatasetDraw(e,o){const{ctx:a,chartArea:n,width:r,height:i}=e,{xAxisID:s,yAxisID:l,controller:c}=o.meta,d={left:0,top:0,right:r,bottom:i};return s&&c.getScaleForId(s)instanceof I&&(d.left=n.left,d.right=n.right),l&&c.getScaleForId(l)instanceof I&&(d.top=n.top,d.bottom=n.bottom),t.clipArea(a,d),!0},afterDatasetDraw(e){t.unclipArea(e.ctx)},beforeEvent(e,t){const o=e.streaming,a=t.event;return"mousemove"===a.type?o.lastMouseEvent=a:"mouseout"===a.type&&delete o.lastMouseEvent,!0},destroy(e){const{scales:o,streaming:a}=e,{canvas:n,mouseEventListener:r}=a;l(a),n.removeEventListener("mousedown",r),n.removeEventListener("mouseup",r),t.each(o,(e=>{e instanceof I&&e.destroy()}))},defaults:{duration:1e4,delay:0,frameRate:30,refresh:1e3,onRefresh:null,pause:!1,ttl:void 0},descriptors:{_scriptable:e=>"onRefresh"!==e}};return a.default.helpers.streaming=c,a.default.register(z,I),z}));
